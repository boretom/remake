diff a/tests/test_driver.pl b/tests/test_driver.pl	(rejected hunks)
@@ -30,6 +30,7 @@
 
 # $Id$
 
+use File::Basename 'dirname';
 
 # The number of test categories we've run
 $categories_run = 0;
@@ -187,25 +161,6 @@ sub toplevel
 
   &print_banner;
 
-  if ($osname eq 'VMS' && $cwdslash eq "")
-  {
-    # Porting this script to VMS revealed a small bug in opendir() not
-    # handling search lists correctly when the directory only exists in
-    # one of the logical_devices.  Need to find the first directory in
-    # the search list, as that is where things will be written to.
-    my @dirs = split("/", $pwd);
-
-    my $logical_device = $ENV{$dirs[1]};
-    if ($logical_device =~ /([A-Za-z0-9_]+):(:?.+:)+/)
-    {
-        # A search list was found.  Grab the first logical device
-        # and use it instead of the search list.
-        $dirs[1]=$1;
-        my $lcl_pwd = join('/', @dirs);
-        $workpath = $lcl_pwd . '/' . $workdir
-    }
-  }
-
   if (-d $workpath)
   {
     print "Clearing $workpath...\n";
@@ -308,13 +263,6 @@ sub get_osname
   # Set up an initial value.  In perl5 we can do it the easy way.
   $osname = defined($^O) ? $^O : '';
 
-  if ($osname eq 'VMS')
-  {
-    $vos = 0;
-    $pathsep = "/";
-    return;
-  }
-
   # Find a path to Perl
 
   # See if the filesystem supports long file names with multiple
@@ -510,7 +458,12 @@ sub run_all_tests
         $perl_testname = "$scriptpath$pathsep$testname";
         $testname =~ s/(\.pl|\.perl)$//;
         $testpath = "$workpath$pathsep$testname";
-        # Leave enough space in the extensions to append a number, even
+
+	chomp($fulltestdir = `pwd`);
+	$testcat = dirname($testname);
+	$fullworkdir = "$fulltestdir$pathsep$workpath$pathsep$testcat";
+
+	# Leave enough space in the extensions to append a number, even
         # though it needs to fit into 8+3 limits.
         if ($short_filenames) {
             $logext = 'l';
@@ -525,7 +478,6 @@ sub run_all_tests
             $runext = 'run';
             $extext = '.';
         }
-        $extext = '_' if $^O eq 'VMS';
         $log_filename = "$testpath.$logext";
         $diff_filename = "$testpath.$diffext";
         $base_filename = "$testpath.$baseext";
@@ -767,130 +719,71 @@ sub compare_output
           $slurp_mod =~ s,\r\n,\n,gs;
 
           $answer_matched = ($slurp_mod eq $answer_mod);
-          if ($^O eq 'VMS') {
-
-            # VMS has extra blank lines in output sometimes.
-            # Ticket #41760
-            if (!$answer_matched) {
-              $slurp_mod =~ s/\n\n+/\n/gm;
-              $slurp_mod =~ s/\A\n+//g;
-              $answer_matched = ($slurp_mod eq $answer_mod);
-            }
 
-            # VMS adding a "Waiting for unfinished jobs..."
-            # Remove it for now to see what else is going on.
-            if (!$answer_matched) {
-              $slurp_mod =~ s/^.+\*\*\* Waiting for unfinished jobs.+$//m;
-              $slurp_mod =~ s/\n\n/\n/gm;
-              $slurp_mod =~ s/^\n+//gm;
-              $answer_matched = ($slurp_mod eq $answer_mod);
-            }
+          # If it still doesn't match, see if the answer might be a regex.
+          if (!$answer_matched && $answer =~ m,^/(.+)/$,) {
+              $answer_matched = ($slurp =~ /$1/);
+              if (!$answer_matched && $answer_mod =~ m,^/(.+)/$,) {
+                  $answer_matched = ($slurp_mod =~ /$1/);
+              }
+          }
+      }
+  }
 
-            # VMS wants target device to exist or generates an error,
-            # Some test tagets look like VMS devices and trip this.
-            if (!$answer_matched) {
-              $slurp_mod =~ s/^.+\: no such device or address.*$//gim;
-              $slurp_mod =~ s/\n\n/\n/gm;
-              $slurp_mod =~ s/^\n+//gm;
-              $answer_matched = ($slurp_mod eq $answer_mod);
-            }
+  if ($answer_matched && $test_passed)
+  {
+    print "ok\n" if $debug;
+    ++$tests_passed;
+    return 1;
+  }
 
-            # VMS error message has a different case
-            if (!$answer_matched) {
-              $slurp_mod =~ s/no such file /No such file /gm;
-              $answer_matched = ($slurp_mod eq $answer_mod);
-            }
+  if (! $answer_matched) {
+    print "DIFFERENT OUTPUT\n" if $debug;
 
-            # VMS is putting comas instead of spaces in output
-            if (!$answer_matched) {
-              $slurp_mod =~ s/,/ /gm;
-              $answer_matched = ($slurp_mod eq $answer_mod);
-            }
+    &create_file (&get_basefile, $answer);
+    &create_file (&get_runfile, $command_string);
 
-            # VMS Is sometimes adding extra leading spaces to output?
-            if (!$answer_matched) {
-               my $slurp_mod = $slurp_mod;
-               $slurp_mod =~ s/^ +//gm;
-               $answer_matched = ($slurp_mod eq $answer_mod);
-            }
+    print "\nCreating Difference File ...\n" if $debug;
 
-            # VMS port not handling POSIX encoded child status
-            # Translate error case it for now.
-            if (!$answer_matched) {
-              $slurp_mod =~ s/0x1035a00a/1/gim;
-              $answer_matched = 1 if $slurp_mod =~ /\Q$answer_mod\E/i;
+    # Create the difference file
 
-            }
-            if (!$answer_matched) {
-              $slurp_mod =~ s/0x1035a012/2/gim;
-              $answer_matched = ($slurp_mod eq $answer_mod);
-            }
+    local($command) = "diff -c " . &get_basefile . " " . $logfile;
+    &run_command_with_output(&get_difffile,$command);
+  }
 
-            # Tests are using a UNIX null command, temp hack
-            # until this can be handled by the VMS port.
-            # ticket # 41761
-            if (!$answer_matched) {
-              $slurp_mod =~ s/^.+DCL-W-NOCOMD.*$//gim;
-              $slurp_mod =~ s/\n\n+/\n/gm;
-              $slurp_mod =~ s/^\n+//gm;
-              $answer_matched = ($slurp_mod eq $answer_mod);
-            }
-            # Tests are using exit 0;
-            # this generates a warning that should stop the make, but does not
-            if (!$answer_matched) {
-              $slurp_mod =~ s/^.+NONAME-W-NOMSG.*$//gim;
-              $slurp_mod =~ s/\n\n+/\n/gm;
-              $slurp_mod =~ s/^\n+//gm;
-              $answer_matched = ($slurp_mod eq $answer_mod);
-            }
+  return 0;
+}
 
-            # VMS is sometimes adding single quotes to output?
-            if (!$answer_matched) {
-              my $noq_slurp_mod = $slurp_mod;
-              $noq_slurp_mod =~ s/\'//gm;
-              $answer_matched = ($noq_slurp_mod eq $answer_mod);
-
-              # And missing an extra space in output
-              if (!$answer_matched) {
-                $noq_answer_mod = $answer_mod;
-                $noq_answer_mod =~ s/\h\h+/ /gm;
-                $answer_matched = ($noq_slurp_mod eq $noq_answer_mod);
-              }
+sub compare_output_string
+{
+  my($answer,$slurp,$logfile) = @_;
+  my($answer_matched) = (0);
 
-              # VMS adding ; to end of some lines.
-              if (!$answer_matched) {
-                $noq_slurp_mod =~ s/;\n/\n/gm;
-                $answer_matched = ($noq_slurp_mod eq $noq_answer_mod);
-              }
+  print "Comparing Output ........ " if $debug;
 
-              # VMS adding trailing space to end of some quoted lines.
-              if (!$answer_matched) {
-                $noq_slurp_mod =~ s/\h+\n/\n/gm;
-                $answer_matched = ($noq_slurp_mod eq $noq_answer_mod);
-              }
+  $slurp = subst_make_string($slurp);
+  $answer = subst_make_string($answer);
 
-              # And VMS missing leading blank line
-              if (!$answer_matched) {
-                $noq_answer_mod =~ s/\A\n//g;
-                $answer_matched = ($noq_slurp_mod eq $noq_answer_mod);
-              }
+  # For make, get rid of any time skew error before comparing--too bad this
+  # has to go into the "generic" driver code :-/
+  $slurp =~ s/^.*modification time .*in the future.*\n//gm;
+  $slurp =~ s/^.*Clock skew detected.*\n//gm;
 
-              # Unix double quotes showing up as single quotes on VMS.
-              if (!$answer_matched) {
-                $noq_answer_mod =~ s/\"//g;
-                $answer_matched = ($noq_slurp_mod eq $noq_answer_mod);
-              }
-            }
-          }
+  ++$tests_run;
 
-          # If it still doesn't match, see if the answer might be a regex.
-          if (!$answer_matched && $answer =~ m,^/(.+)/$,) {
-              $answer_matched = ($slurp =~ /$1/);
-              if (!$answer_matched && $answer_mod =~ m,^/(.+)/$,) {
-                  $answer_matched = ($slurp_mod =~ /$1/);
-              }
-          }
-      }
+  if ($slurp eq $answer) {
+    $answer_matched = 1;
+  } else {
+    # See if it is a slash or CRLF problem
+    my ($answer_mod) = $answer;
+
+    $answer_mod =~ tr,\\,/,;
+    $answer_mod =~ s,\r\n,\n,gs;
+
+    $slurp =~ tr,\\,/,;
+    $slurp =~ s,\r\n,\n,gs;
+
+    $answer_matched = ($slurp eq $answer_mod);
   }
 
   if ($answer_matched && $test_passed)
@@ -901,19 +794,25 @@ sub compare_output
   }
 
   if (! $answer_matched) {
-    print "DIFFERENT OUTPUT\n" if $debug;
+      if ($debug) {
+	  print "DIFFERENT OUTPUT\n";
+	  print "+++1:\n$answer\n";
+	  print "+++2:\n$slurp\n";
+      }
 
     &create_file (&get_basefile, $answer);
-    &create_file (&get_runfile, $command_string);
 
     print "\nCreating Difference File ...\n" if $debug;
 
     # Create the difference file
 
+    open(LOGFILE, ">$logfile") && print(LOGFILE $slurp) && close(LOGFILE);
+
     local($command) = "diff -c " . &get_basefile . " " . $logfile;
     &run_command_with_output(&get_difffile,$command);
   }
 
+  $suite_passed = 0;
   return 0;
 }
 
@@ -995,30 +894,6 @@ sub _run_command
   resetENV();
 
   eval {
-      if ($^O eq 'VMS') {
-          local $SIG{ALRM} = sub {
-              my $e = $ERRSTACK[0];
-              print $e "\nTest timed out after $test_timeout seconds\n";
-              die "timeout\n"; };
-#          alarm $test_timeout;
-          system(@_);
-          my $severity = ${^CHILD_ERROR_NATIVE} & 7;
-          $code = 0;
-          if (($severity & 1) == 0) {
-              $code = 512;
-          }
-
-          # Get the vms status.
-          my $vms_code = ${^CHILD_ERROR_NATIVE};
-
-          # Remove the print status bit
-          $vms_code &= ~0x10000000;
-
-          # Posix code translation.
-          if (($vms_code & 0xFFFFF000) == 0x35a000) {
-              $code = (($vms_code & 0xFFF) >> 3) * 256;
-          }
-      } else {
           my $pid = fork();
           if (! $pid) {
               exec(@_) or die "Cannot execute $_[0]\n";
@@ -1027,8 +902,7 @@ sub _run_command
           alarm $test_timeout;
           waitpid($pid, 0) > 0 or die "No such pid: $pid\n";
           $code = $?;
-      }
-      alarm 0;
+	  alarm 0;
   };
   if ($@) {
       # The eval failed.  If it wasn't SIGALRM then die.
@@ -1133,15 +1005,7 @@ sub remove_directory_tree_inner
     }
     else
     {
-      if ($^O ne 'VMS')
-      {
-        unlink $object || return 0;
-      }
-      else
-      {
-        # VMS can have multiple versions of a file.
-        1 while unlink $object;
-      }
+      unlink $object || return 0;
     }
   }
   closedir ($dirhandle);
